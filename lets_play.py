#    Здравствуйте. Не обладая, пока (надеюсь), достаточным уровнем развития навыков быстрого написания кода, решил обработать этот код 
# и показать свой уровень (насколько это возможно) понимания с помощью написания комментариев. Естественно, код был мною "подерган", "поломан", прослежен до конца 
# и в принципе понят. Переписывать на более (доступные моему пониманию) варианты не стал, в пояснительном вэбинаре были рассмотрено почти всё, 
# есть ещё достаточно примеров написания данной игры на YouTube. 

#   Код начинается с объявления трех рабочих (служебных) функций: show_field(), users_input(), win_position(), вызов которых осуществляется изнутри 
# главной функции-движка: start(), объявленной последней. В глобальной области видимости находится переменная "field", которая содержит в себе, так называемый, 
# двумерный список (матрицу) [] 3х3, элементы которого тоже списки - он нужен для создания структуры игрового поля, записи и хранения ходов участников.
# Запуск программы - это вызов функции start(field), с переданным ей аргументом.    


#### Объявляемая show_field(f) получает в качестве аргумента сисок "field", но не напрямую, значение аргумента передается из главной функции start(), которая получает
# его уже из глобальной области видимости.
# Данная функция реализует вывод - визуализацию условного поля игры  
def show_field(f):
    # "Отрисовываем" первую строку, которая нумерует столбцы поля игры
    num ='  0 1 2'
    print(num)
    # Далее, цикл for перебирает каждый элемент (кортежей) получившихся благодаря объединяющему методу zip(): 
    # объединяются два списка: список "field" 
    # и список получившийся из строки "num" благодаря методу split() [0, 1, 2]
    # – результат объединения с помощью zip() такой: (['-', '-', '-'], '0'), (['-', '-', '-'], '1'), (['-', '-', '-'], '2'), три кортежа 1-й элемент список, 2-й строчный.
    # При каждом переборе (скачке), с помощью print(), второй элемент кортежа "i", являясь как бы также счетчиком для 2-го перебора,  
    # выводится как есть, а первый обозначенный как "row", т.к. это список, перебирается еще раз и с помощью метода ' '.join() из списка
    # преобразовывается в тоже в строку и объединяется поэлементно через пробел. 

    for row, i in zip(f, num.split()):
        print (f"{i} {' '.join(str(j) for j in row)}")


#### Объявляемая users_input(f, user) - обрабатывает введенные игроком данные и возвращает их в главную функцию start() 
def users_input(f, user):
    while True:
        place = input(f"Ходит {user} .Введите координаты:").split()
        # Введенные игроком данные преобразовываются в список строчных элементов разделенных, по умолчанию, по пробелу в таком виде: ["1", "0"]
        
        # Далее следует проверка введенных данных
        # Если ввели не два элемента (значения), то цикл начинается заново
        if len(place) != 2:
            print('Введите две координаты')
            continue
        #Проверка были ли введены цифровые данные, если нет цикл переходит к началу опять
        if not(place[0].isdigit() and place[1].isdigit()):
            print('Введите числа')
            continue
        
        # С помощью метода map(int, ) переводим каждый элемент списка "place" в целочисленный тип из строчного 
        # и записываем каждый элемент списка в переменные x = place[0], y = place[1]
        x, y = map(int, place)
        
        # Ещё две проверки введенных данных, уже преобразованных в integer тип данных
        if not(x>=0 and x<3 and y>=0 and  y<3):
            print('Вышли из диапазона')
            continue
        # На данном этапе вызывается проверка ввденных координат на сличение с элементом в списке "field", если под данным идексом не находится 
        # строчный элемент '-', значит там уже есть присвоенное новое значение 'x' или 'o', значит место занято и цикл откатывается к своему началу.
        if f[x][y]!='-':
            print('Клетка занята')
            continue
        break
    # После успешной отработки данной функции она передает главной функции start() цифровые (целочисленные) значения x y. 
    return x,y

#### Объявляемая win_position(f, user), осуществляет проверку
def win_position(f, user):
    f_list=[]
    # print(f) 
    # список "field" на входе в данную функцию имеет вид: 
    # [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']] (правда, в него уже будет передано одно или несколько значений инпута, 
    # в зависимости от круга глобальной - центральной  интерации, инициируемой функцией start())
    for l in f:
        f_list += l
    # print(f_list) 
    # переписанные в новый список элементы двумерного списка с помощью цикла for ['-', '-', '-', '-', '-', '-', '-', '-', '-']
    # и получаем линейный - обычный список с нумерацией идексов элементов от 0 до 8

    # создаем список внутри которого списки с "выигрышными комбинациями" индексов из преобразованного на предыдущем шаге списка "f_list"
    positions = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]
    # 
    # 
    # enumerate(f_list) преобразовывает список "f_list" в объект, в котором каждый элемент зафиксирован со своим идексом (индекс, значение = Н-р, (0, '-'), (1, '-')..),
    # поэтому, если на каком-то шаге интерации цикла for ("i" соответствует индексу, "x" - значению) второй элемент итерируемого объекта, 
    # т.е. значение, равно текущему значению "user", то во множество (благодаря преобразованию set()) "indexes" записывается "индекс" места в изначальном списке "f_list",
    # на котором было значение "x"  или "o"
    indexes = set([i for i, x in enumerate(f_list) if x == user])
    
    # Далее идет цикл for с помощью перебора списка "positions" по его элементам происходит сличение выигрышных значений (индексов) 
    # с полученными на данном этапе (работы функции start()) значениями (индексами - ходами) актуального "user", 
    # которые мы должны были получить как множество "indexes" на предыдущем шаге.  
    
    # indexes.intersection(set(p)) - (сличает) находит элементы встречающиеся и в множестве "indexes"и в множестве, 
    # получаемом на каждом шаге перебора по элементам списка "positions", в котором 8 элементов, значит интерация происходит 8 раз 
    # и каждый раз проверяется длина len() полученного множества - равна ли она 3, 
    # т.е. если пересеклись значения множеств на одном из циклов перебора (как бы сличения с одним из элементов списка "positions") так, что все три совпали,
    # и в образовашемся множестве три элемента, то возвращается значение True, что по логике прописанной в главной функции "start()" значит выигрыш (и прерывание цикла while командой break).   
    for p in positions:
        if len(indexes.intersection(set(p))) == 3:
            return True
    return False

#### start(field) - центральная функция «движок» - запускает все составленные выше функции по основной логике (алгоритму) хода игры
# в нее в качестве аргумента передается значение переменной field – двумерный список (матрица) 3х3
def start(field):
    
# устанавливаем счетчик интераций "count" (в данном случае он олицетворяет количество ходов в игре)
# и запускаем потенциально бесконечный цикл while, выход из которого регулируется с помощье break

# Очередность ходов: четные это "x" – первый ход – счетчик цикла "count" на старте в значении ноль, делится на 2 без
# остатка, следующий ход - нечетные "o" – значение счетчика 1 деление на 2 с остатком и т.д. в зависимости от этого
# перезаписывается переменная "user"
    count = 0
    while True:
        # вызов функции "отрисовки поля игры"
        show_field(field) 
        # очередность хода
        if count % 2 == 0:
            user = 'x'
        else:
            user = 'o'
      # Если ещё не превышено количество ходов, а их 9, то запускается функция "users_input", которая обрабатывает данные
      # введенные игроком, при запуске в нее передаются, как аргументы, актуальные значения переменных "user" и "field";
      # А переданные этой функцией после обработки данные (целочисленные значения x и y), записываются в качестве индексов
      # списка "field" и элементу, находящемуся на этом месте в списке присваивается новое (текущее) значение переменной "user" - 
      # ("x" или "o")   
        if count < 9:
            x, y = users_input(field, user)
            field[x][y] = user
    
      # Если счетчик "насчитал" 9 итераций, и не произошло события, обрабатываемого в последнем шаге этой функции, т.е. при
      # обработке данных последней вызываемой здесь функцией "win_position" даже до 9-го хода не вернулось значение "True",
      # значит победитель не определен – "ничья" - цикл принудительно прерывается комадой "break"
        elif count == 9:
            print ('Ничья')
            break
        if win_position(field, user):
            show_field(field)
            print(f"Выйграл {user}")
            break
        count+=1

#### Создание переменной "field"  и запись в неё списка: [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]
field = [['-'] * 3 for _ in range(3)]

#### Вызов главной функции
start(field)
print()
print("------------")
end_question = input("чтобы выйти, нажмите любую кнопку:  ")
if end_question:
    exit()
        
